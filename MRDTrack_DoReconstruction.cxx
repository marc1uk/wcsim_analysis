/* vim:set noexpandtab tabstop=4 wrap */
// =====================================================================
// ********* trajectory reconstruction: main *****************
/* information received during construction */
// event information: MRDtrackID, wcsimfile, run_id, event_id, subtrigger, digi_ids, 
// digit information: pmts_hit, digi_qs, digi_ts, 
// truth information: digi_numphots, digi_phot_ts, digi_phot_parents
/* make functions to retrieve these? */
// digits(), trueTrackID(-1)
// ------------------------
// 
/* information to calculate here: */
// TODO: KEStart(), KEEnd(), particlePID(), tracktype() (one track, 2 tracks, inconsistent hits...),
// Done: layers_hit(), eDepsInLayers(), recovalshoriz(), recovalsvert()
// ^^^^^^^^^^^^^^^^^^^^^^^^

#ifndef MRDTrack_RECO_VERBOSE
//#define MRDTrack_RECO_VERBOSE
#endif

void cMRDTrack::DoReconstruction(){
#ifdef MRDTrack_RECO_VERBOSE
	cout<<"doing track reconstruction"<<endl;
#endif
	/* 
	Reconstruction generates two maps (recovalshoriz, recovalsvert) each with keys: 
	(xycrossing, zcrossing, angmax, angmin)
	These values define the region of acceptance in that plane - projecting from the crossing points,
	the angles define a wedge in the x-z / y-z plane.
	This wedge, projected back to the tank, defines the region of possible starting points and angles
	within the tank 
	Tracks starting from a point in this region must have the appropriate angle to hit the crossing vertex.
	The two sets of constraints in x and y are independent and define a non-trivial geometry when combined.*/
	
	int numdigits = digi_ids.size();
	std::vector<TVector3> bottompoints;
	std::vector<TVector3> toppoints;
	
#ifdef MRDTrack_RECO_VERBOSE
	cout<<"getting hit layers and energy depositions"<<endl;
#endif
	for(Int_t i=0;i<numdigits;i++){
		// get the extent of the corresponding paddle
		int digiindex = digi_ids.at(i);
		Int_t tube_id = pmts_hit.at(i);
		Int_t strucklayer = mrdcluster::paddle_layers.at(tube_id);
		if(std::count(layers_hit.begin(), layers_hit.end(), strucklayer)==0){
			layers_hit.push_back(strucklayer);
		}
		eDepsInLayers.at(strucklayer)+= (digi_qs.at(i));	// TODO: convert q to energy?
	}
	
#ifdef MRDTrack_RECO_VERBOSE
	cout<<"creating TGraphErrors arrays"<<endl;
#endif
	// Reconstruction based on a fit to a TGraphErrors of paddles, using extent of clusters as errors
	//std::vector<mrdcluster> htrackclusters;	// generated by CA algorithm
	//std::vector<mrdcluster> vtrackclusters;	// 
	std::vector<double> hclusterzpositions, hclusterxpositions, hclusterzerrors, hclusterxerrors;
	for(auto acluster : htrackclusters){
		hclusterzpositions.push_back(mrdscintlayers.at(acluster.layer));
		hclusterxpositions.push_back(acluster.GetCentre()/10.);
		hclusterzerrors.push_back(scintfullzlen);
		hclusterxerrors.push_back(TMath::Abs(acluster.GetXmax()-acluster.GetXmin())/10.);
	}
	std::vector<double> vclusterzpositions, vclusterxpositions, vclusterzerrors, vclusterxerrors;
	for(auto acluster : vtrackclusters){
		vclusterzpositions.push_back(mrdscintlayers.at(acluster.layer));
		vclusterxpositions.push_back(acluster.GetCentre()/10.);
		vclusterzerrors.push_back(scintfullzlen);
		vclusterxerrors.push_back(TMath::Abs(acluster.GetXmax()-acluster.GetXmin())/10.);
	}
	
#ifdef MRDTrack_RECO_VERBOSE
	cout<<"creating TGraphErrors hclustergraph"<<endl;
#endif
	TGraphErrors hclustergraph = TGraphErrors(htrackclusters.size(), &hclusterzpositions[0], &hclusterxpositions[0], &hclusterzerrors[0], &hclusterxerrors[0]);
	
#ifdef MRDTrack_RECO_VERBOSE
	cout<<"creating TGraphErrors vclustergraph"<<endl;
#endif
	TGraphErrors vclustergraph = TGraphErrors(vtrackclusters.size(), &vclusterzpositions[0], &vclusterxpositions[0], &vclusterzerrors[0], &vclusterxerrors[0]);
	
#ifdef MRDTrack_RECO_VERBOSE
	cout<<"Drawing and getting fit parameters"<<endl;
#endif
	TCanvas c1;
	hclustergraph.Draw("AP");
	TF1 htrackfit("htrackfit","pol1",MRD_start,(MRD_start+MRD_depth));
	htrackfit.SetParameters(0,0);
	TFitResultPtr htrackfitresult = hclustergraph.Fit(&htrackfit,"SR");
	htrackorigin = htrackfitresult->Value(0);
	htrackoriginerror = htrackfitresult->ParError(0);
	htrackgradient = htrackfitresult->Value(1);
	htrackgradienterror = htrackfitresult->ParError(1);
	htrackfitchi2 = htrackfitresult->Chi2();
	
	//c1.SaveAs(TString::Format("htrackfit_%d.png",MRDtrackID));
	
	c1.Clear();
	vclustergraph.Draw("AP");
	TF1 vtrackfit("vtrackfit","pol1",MRD_start,(MRD_start+MRD_depth));
	vtrackfit.SetParameters(0,0);
	TFitResultPtr vtrackfitresult = vclustergraph.Fit(&vtrackfit,"SR");
	vtrackorigin = vtrackfitresult->Value(0);
	vtrackoriginerror = vtrackfitresult->ParError(0);
	vtrackgradient = vtrackfitresult->Value(1);
	vtrackgradienterror = vtrackfitresult->ParError(1);
	vtrackfitchi2 = vtrackfitresult->Chi2();
	//c1.SaveAs(TString::Format("vtrackfit_%d.png",MRDtrackID));
	
#ifndef MRDTrack_RECO_VERBOSE
	cout<<"htrack fit had angle "<<((180/TMath::Pi())*TMath::ATan(htrackgradient))<<endl;
	cout<<"fit parameters were "<<htrackorigin<<", "<<htrackgradient
		<<" with errors "<<htrackoriginerror<<", "<<htrackgradienterror<<endl;
	cout<<"vtrack fit had angle "<<((180/TMath::Pi())*TMath::ATan(vtrackgradient))<<endl;
	cout<<"fit parameters were "<<vtrackorigin<<", "<<vtrackgradient
		<<" with errors "<<vtrackoriginerror<<", "<<vtrackgradienterror<<endl;
#endif
	
	// calculate track fit start and endpoints from frontmost and backmost cell z values,
	// and fit formulae to determine x and y
	// TODO:??? Should we over-ride this with a projection back to the MRD start?
	//Double_t trackfitstartz = TMath::Min(mrdscintlayers.at(vtrackclusters.back().layer),
	//						mrdscintlayers.at(htrackclusters.back().layer));
	Double_t trackfitstartz = MRD_start; // seems more accurate in cases of revelevance
	Double_t trackfitstarty = htrackorigin + htrackgradient*trackfitstartz;
	Double_t trackfitstartx = vtrackorigin + vtrackgradient*trackfitstartz;
	Double_t trackfitstopz = TMath::Max(mrdscintlayers.at(vtrackclusters.front().layer),
							mrdscintlayers.at(htrackclusters.front().layer));
	Double_t trackfitstopy = htrackorigin + htrackgradient*trackfitstopz;
	Double_t trackfitstopx = vtrackorigin + vtrackgradient*trackfitstopz;
	
	trackfitstart = TVector3(trackfitstartx,trackfitstarty,trackfitstartz);
	trackfitend = TVector3(trackfitstopx,trackfitstopy,trackfitstopz);
	
	// define 'fiducial' MRD volume to call tracks that stop sufficiently far from MRD edges as 
	// 'stopping'
	double depthfidfrac = 0.9;
	double widthfidfrac = 0.9;
	double heightfidfrac = 0.9;
	if( TMath::Abs(trackfitstopz)>((MRD_start+MRD_depth)*depthfidfrac)){
		double projectedxexit = vtrackorigin + vtrackgradient*MRD_end;
		double projectedyexit = htrackorigin + htrackgradient*MRD_end;
		if( (TMath::Abs(projectedxexit)<MRD_width) && (TMath::Abs(projectedyexit)<MRD_height) ){
			ispenetrating=true;
		} else {
			sideexit=true;
		}
	} else if ( (TMath::Abs(trackfitstopx)>(MRD_width*widthfidfrac))   ||
				(TMath::Abs(trackfitstopy)>(MRD_height*heightfidfrac)) )
		sideexit=true;
	} else {
		isstopped=true;
	}
	
	/* Match to a tank track. Project back to the tank, and look for a track with 
	   an exit point sufficiently close to the back-projected point, and with agreeable alignment */
	
	// first as it's easiest, check if projection vertically actually enters tank height.
	double projectedtankexity = htrackorigin 
		 - htrackgradient*((mrdscintlayers.at(htrackclusters.back().layer))-tank_start+(2*tank_radius));
	double projectedtankexitz, projectedtankexitx;
	if(TMath::Abs(projectedtankexity-tank_yoffset)>tank_halfheight){
		tankintercept=false;
	} else {
		// we know the track at least has height within the tank.
		// we now need to try to find an intercept in X-Z plane.
		// from simultaneous equations:
		// 1)  x^2 + z^2 = r^2
		// 2)  x = x0 + m*(z - z0) = m*z + (x0 - m*z0) = m*z + c (<< defines 'c')
		// we obtain:
		// z_intercept = [ -mc +/- Sqrt(m^2*c^2 + (1+m^2)*(r^2-c^2)) ] / (2*(1+m^2))
		// (with z axis shifted to centre of tank)
		double z0 = mrdscintlayers.at(vtrackclusters.back().layer) - tank_start - tank_radius;
		double linec = vtrackorigin - (vtrackgradient*z0);
		double coeffa = (1+vtrackgradient^2);
		double coeffb = (2*vtrackgradient*linec);
		double coeffc = -((tank_radius^2) - (linec^2));
		// first check if there is an intercept
		double determinnt = (coeffb^2) - 4*coeffa*coeffc;
		if(determinnt>=0){
			tankintercept=true;
			projectedtankexitz = ( -coeffb + TMath::Sqrt(determinnt) ) / (2*coeffa);
			projectedtankexitz += tank_start + tank_radius; // remove tank-centering offset
			projectedtankexitx = vtrackorigin 
				 - (vtrackgradient*(mrdscintlayers.at(vtrackclusters.back().layer)-projectedtankexitz));
		} else {
			tankintercept=false;
		}
	}
	if(tankintercept){ 
		projectedtankexitpoint=TVector3(projectedtankexitx,projectedtankexity,projectedtankexitz);
		
		// we have a projected point that intercepts the tank. Search tank track exit vertices
		// for a close match, both in location and in angle.
		SearchForTankMatch(projectedtankexitpoint,vtrackgradient,htrackgradient);
		// this should also return if a match was found, and maybe a value for the track start?
	}
	
	penetrationdepth=trackfitstopz-MRD_start;
	// determine energy of particle from track length and rate of energy loss.
	// TODO: investigate if we lose significant resolution using lookup based just on final z & angle
	TVector3 differencevector  = trackfitend - trackfitstart;
	TVector3 azaxisvector(0,0,1);
	trackangle = differencevector.Angle(azaxisvector);
	// TODO: MRDenergyvspenetration assumes a muon. Should we have functions for other particles?
	double dEdx = MRDenergyvspenetration.Eval(trackangle);
	// calculate the total track length in cm
	double muXdistanceinMRD=trackfitstopx-trackfitstartx;
	double muYdistanceinMRD=trackfitstopy-trackfitstarty;
	double mutracklengthinMRD=
		TMath::Sqrt(TMath::Power(muXdistanceinMRD,2)+TMath::Power(muYdistanceinMRD,2)
		+TMath::Power(penetrationdepth,2));
	// calculate the energy loss
	EnergyLoss = mutracklengthinMRD*dEdx;
	
}

void cMRDTrack::DrawFit(TCanvas* imgcanvas, std::vector<TArrow*> &trackfitarrows, EColor thistrackscolour){
	Double_t mrdentryx = trackfitstart.X();
	Double_t mrdentryy = trackfitstart.Y();
	Double_t mrdentryz = trackfitstart.Z()
	Double_t mrdexitx = trackfitend.X();
	Double_t mrdexity = trackfitend.Y();
	Double_t mrdexitz = trackfitend.Z();

//	for debugging
//	Double_t mrdentryz = mrdcluster::paddle_originz.at(14)/10.;
//	Double_t mrdentryx = mrdcluster::paddle_originx.at(14)/10.;
//	Double_t mrdentryy = mrdcluster::paddle_originy.at(14)/10.;
//	Double_t mrdexitz = mrdcluster::paddle_originz.at(294)/10.;
//	Double_t mrdexitx = mrdcluster::paddle_originx.at(294)/10.;
//	Double_t mrdexity = mrdcluster::paddle_originy.at(294)/10.;
	
#ifdef MRDTrack_RECO_VERBOSE
	cout<<"mrd entry point is ("<<mrdentryx<<", "<<mrdentryy<<", "<<mrdentryz<<")"<<endl;
	cout<<"mrd exit point is ("<<mrdexitx<<", "<<mrdexity<<", "<<mrdexitz<<")"<<endl;
#endif
	
	// up to now all measurements are in WCSim absolute coordinates. Shift z axis so that
	// the MRD is centered on (0,0);
	mrdentryz -= (MRD_start+(MRD_depth/2.));
	mrdexitz -= (MRD_start+(MRD_depth/2.));
	
	bool trackisbackwardgoing=false;
	
#ifdef MRDTrack_RECO_VERBOSE
	cout<<"shifting z axis; new entry and exit points are "<<mrdentryz<<" and "<<mrdexitz<<endl;
	cout<<"entry and exit points in terms of mrd width, height and depth are: ("
		<<(mrdentryx/maxwidth)<<", "<<(mrdentryy/maxheight)<<", "<<(mrdentryz/mrdZlen)<<") -> ("
		<<(mrdexitx/maxwidth)<<", "<<(mrdexity/maxheight)<<", "<<(mrdexitz/mrdZlen)<<")"<<endl;
#endif
	
	// the following is code copied from DrawTruthTracks, as it converts cm to canvas units,
	// accounts for offsets with side, and draws the necessary arrows
	
	// scale cm to canvas size and offset to start of MRD diagram
	/*  ✩ ✨ Magic Numbers! ✨ ✩ */
	double anoffset=(scintfullzlen+scintalugap)*5.;  // this offset accounts for the half shift
	double topscalefactor=1.5;           // compress canvas width to paddle diagram height
	double sidescalefactor=1.55;         //   "         "      "       "       "    width
	double topdepthscalefactor=1.18;     //   "         "      "       "       "    depth (top view)
	double sidedepthscalefactor=1.2;     // compress canvas depth to paddle diagram depth (side view)
	double xscalefactor=(0.5/0.403825);  // correct differences in definition of MRD width and height
	double yscalefactor=(0.5/0.384671);  // between this method and that for paddle placements
	double topzoffset=0.0;               // shifts the track arrows +z          (top  view)
	double sidezoffset=0.0;              // to account for centering of diagram (side view)
	
	mrdentryx*=xscalefactor;
	mrdexitx*=xscalefactor;
	mrdentryy*=yscalefactor;
	mrdexity*=yscalefactor;
#ifdef MRDTrack_RECO_VERBOSE
	cout<<"scaled entry and exit points in terms of mrd width, height and depth are: ("
		<<(mrdentryx/maxwidth)<<", "<<(mrdentryy/maxheight)<<", "<<(mrdentryz/mrdZlen)<<") -> ("
		<<(mrdexitx/maxwidth)<<", "<<(mrdexity/maxheight)<<", "<<(mrdexitz/mrdZlen)<<")"<<endl;
#endif
	
	// one last thing: the beam comes from the left. In the top view, right-hand-side (x>0)
	// needs to map to the bottom of the canvas (canvas_y<0) - so, let's swap the signs of all
	// x points
	mrdentryx*=-1.;
	mrdexitx*=-1.;
	Double_t avgtrackanglex=-1.*vtrackgradient;
	Double_t avgtrackangley=htrackgradient;
	
	std::vector<double> xstarts, ystarts, zstartsx, zstartsy, xstops, ystops, zstopsx, zstopsy;
	xstarts.push_back((mrdentryx/(maxwidth*topscalefactor))+0.5);
	ystarts.push_back((mrdentryy/(maxheight*sidescalefactor))+0.5);
	// starting z may need a shift depending on the appropriate half
	// in top view
	if(mrdentryy>0){
		zstartsx.push_back((mrdentryz/(mrdZlen*topdepthscalefactor))+0.5+topzoffset);
	} else {
		zstartsx.push_back(((mrdentryz+anoffset)/(mrdZlen*topdepthscalefactor))+0.5+topzoffset);
	}
	// in side view
	if(mrdentryx>0){
		zstartsy.push_back((mrdentryz/(mrdZlen*sidedepthscalefactor))+0.5+sidezoffset);
	} else {
		zstartsy.push_back(((mrdentryz+anoffset)/(mrdZlen*sidedepthscalefactor))+0.5+sidezoffset);
	}
	// check if we cross sides, and if so, create a middle stop and start set
	// top view
	if((mrdentryy*mrdexity)<0){
		// we'll need two lines with a bit of a disconnect. find the crossing point.
		double crossingz = mrdentryz-((mrdentryy/yscalefactor) / /*TMath::Tan*/(avgtrackangley));
		double crossingx = (mrdentryx/xscalefactor) + ((crossingz-mrdentryz)*avgtrackanglex);
		xstops.push_back(((crossingx*xscalefactor)/(maxwidth*topscalefactor))+0.5);
		if(mrdentryy>0){
			zstopsx.push_back((crossingz/(mrdZlen*topdepthscalefactor))+0.5+topzoffset);
		} else {
			zstopsx.push_back(((crossingz+anoffset)/(mrdZlen*topdepthscalefactor))+0.5+topzoffset);
		}
		xstarts.push_back(((crossingx*xscalefactor)/(maxwidth*topscalefactor))+0.5);
		if(mrdexity>0){
			zstartsx.push_back((crossingz/(mrdZlen*topdepthscalefactor))+0.5+topzoffset);
		} else {
			zstartsx.push_back(((crossingz+anoffset)/(mrdZlen*topdepthscalefactor))+0.5+topzoffset);
		}
	}
	// side view
	if((mrdentryx*mrdexitx)<0){
		// we'll need two lines with a bit of a disconnect. find the crossing point.
		double crossingz = mrdentryz-((mrdentryx/xscalefactor) / /*TMath::Tan*/(avgtrackanglex));
		double crossingy = (mrdentryy/yscalefactor) + ((crossingz-mrdentryz)*avgtrackangley);
		ystops.push_back(((crossingy*yscalefactor)/(maxheight*sidescalefactor))+0.5);
		if(mrdentryx>0){
			zstopsy.push_back((crossingz/(mrdZlen*sidedepthscalefactor))+0.5+sidezoffset);
		} else {
			zstopsy.push_back(((crossingz+anoffset)/(mrdZlen*sidedepthscalefactor))+0.5+sidezoffset);
		}
		ystarts.push_back(((crossingy*yscalefactor)/(maxheight*sidescalefactor))+0.5);
		if(mrdexitx>0){
			zstartsy.push_back((crossingz/(mrdZlen*sidedepthscalefactor))+0.5+sidezoffset);
		} else {
			zstartsy.push_back(((crossingz+anoffset)/(mrdZlen*sidedepthscalefactor))+0.5+sidezoffset);
		}
	}
	// finally add the endpoint values, with offset for z according to ending MRD half.
	xstops.push_back((mrdexitx/(maxwidth*topscalefactor))+0.5);
	ystops.push_back((mrdexity/(maxheight*sidescalefactor))+0.5);
	// top view
	if(mrdexity>0){
		zstopsx.push_back((mrdexitz/(mrdZlen*topdepthscalefactor))+0.5+topzoffset);
	} else {
		zstopsx.push_back(((mrdexitz+anoffset)/(mrdZlen*topdepthscalefactor))+0.5+topzoffset);
	}
	// side view
	if(mrdexitx>0){
		zstopsy.push_back((mrdexitz/(mrdZlen*sidedepthscalefactor))+0.5+sidezoffset);
	} else {
		zstopsy.push_back(((mrdexitz+anoffset)/(mrdZlen*sidedepthscalefactor))+0.5+sidezoffset);
	}
	
	// OK done.
	// now loop over the pairs and make the arrows
	// top view
	for(int i=0; i < zstartsx.size(); i++){
		// Draw arrow representing "true" (assumed straight) trajectory in top view
		std::string arrowdir = (!trackisbackwardgoing) ? ">" : "<";
		TArrow* myarrow = 
			new TArrow(zstartsx.at(i), xstarts.at(i), zstopsx.at(i), xstops.at(i), 0.005, arrowdir.c_str());
		myarrow->SetLineWidth(2);
		myarrow->SetLineColor(thistrackscolour);
		myarrow->SetLineStyle(2);  //dashed
		imgcanvas->cd(2);  // top view for x positions
		myarrow->Draw();
#ifdef MRDTrack_RECO_VERBOSE
		cout<<"drawing top view fit track arrow from "<<myarrow->GetX1()<<", "<<myarrow->GetY1()
			<<" to "<<myarrow->GetX2()<<", "<<myarrow->GetY2()<<endl;
#endif
		trackfitarrows.push_back(myarrow);
		
		if(zstartsx.size()==2&&i==0){
			// add an intermediate link dashed line to link the arrows
			myarrow = 
				new TArrow(zstopsx.at(i), xstops.at(i), zstartsx.at(i+1), xstarts.at(i+1),0.0,">");
				// an arrow size of 0.0 gives no arrow head (just a line)
			myarrow->SetLineWidth(2);
			myarrow->SetLineColor(thistrackscolour);
			myarrow->SetLineStyle(3);  //dotted
			myarrow->Draw();
#ifdef MRDTrack_RECO_VERBOSE
			cout<<"drawing line from "<<myarrow->GetX1()<<", "<<myarrow->GetY1()<<" to "
				<<myarrow->GetX2()<<", "<<myarrow->GetY2()<<endl;
#endif
			trackfitarrows.push_back(myarrow);
		}
	}
	
	// need to do top and side views separately as they may have different sizes
	// side view
	for(int i=0; i < zstartsy.size(); i++){
		// Draw arrow representing "true" (assumed straight) trajectory in top view
		std::string arrowdir = (!trackisbackwardgoing) ? ">" : "<";
		TArrow* myarrow = 
			new TArrow(zstartsy.at(i), ystarts.at(i), zstopsy.at(i), ystops.at(i), 0.005, arrowdir.c_str());
		myarrow->SetLineWidth(2);
		myarrow->SetLineColor(thistrackscolour);
		myarrow->SetLineStyle(2);  //dashed
		imgcanvas->cd(1);  // side view for y positions
		myarrow->Draw();
#ifdef MRDTrack_RECO_VERBOSE
		cout<<"drawing side view fit track arrow from "<<myarrow->GetX1()<<", "
		<<myarrow->GetY1()<<" to "<<myarrow->GetX2()<<", "<<myarrow->GetY2()<<endl;
#endif
		trackfitarrows.push_back(myarrow);
		
		if(zstartsy.size()==2&&i==0){
			// add an intermediate link dashed line to link the arrows
			myarrow = 
				new TArrow(zstopsy.at(i), ystops.at(i), zstartsy.at(i+1), ystarts.at(i+1),0.0,">");
				// an arrow size of 0.0 gives no arrow head (just a line)
			myarrow->SetLineWidth(2);
			myarrow->SetLineColor(thistrackscolour);
			myarrow->SetLineStyle(3);  //dotted
			myarrow->Draw();
#ifdef MRDTrack_RECO_VERBOSE
			cout<<"drawing line from "<<myarrow->GetX1()<<", "<<myarrow->GetY1()<<" to "
				<<myarrow->GetX2()<<", "<<myarrow->GetY2()<<endl;
#endif
			trackfitarrows.push_back(myarrow);
		}
	}
}
