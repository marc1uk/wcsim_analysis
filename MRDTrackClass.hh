/* vim:set noexpandtab tabstop=4 wrap */
#ifndef MRDTrack_VERBOSE
//#define MRDTrack_VERBOSE 1
#endif

#ifndef _MRDTrack_Class_
#define _MRDTrack_Class_ 1

#include <TObject.h>
#include "Math/Vector3D.h"
#include "Math/Vector4D.h"
#include "TVector3.h"
#include "TText.h"
#include "TBox.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "TGraph.h"
#include "TGraphErrors.h"
#include "TF1.h"
#include "TFitResult.h"
#include "TMinuit.h"
#include "TMatrixD.h"
#include "TVirtualFitter.h"
#include "Math/GenVector/PxPyPzE4D.h"
#include "Math/GenVector/LorentzVector.h"
#include <exception>	// for stdexcept
#include <vector>
#include <algorithm>
#include <map>
#include "MRDspecs.hh"
#include "MRDSubEvent_ReconstructionClasses.hh"

class cMRDTrack : public TObject {
	
	// Private members
	// ===============
	public:	//TODO public for copy constructor
	Int_t MRDtrackID;						// ID of this track within the trigger
	Int_t tanktrackID;						// correlated tank track within the trigger
	
	// Raw Info:
	std::string wcsimfile;					// which wcsim file this was in
	Int_t run_id;							// which run this file was in TODO all 0
	Int_t event_id;							// which event this track was in
	Int_t trigger;							// which (sub)trigger this track was in TODO? all 1
	Int_t mrdsubevent_id;					// which subevent this track was in
	std::vector<Int_t> digi_ids;			// vector of digi ids: GetCrnkvDigiHits()->At(digi_ids.at(i)) TODO v
	std::vector<Int_t> pmts_hit;			// vector of PMT IDs TODO empty
	std::vector<Double_t> digi_qs;			// vector of digit charges TODO empty
	std::vector<Double_t> digi_ts;			// vector of digit times TODO empty
	std::vector<Int_t> digi_numphots;		// number of true photons for each digit TODO empty
	std::vector<Double_t> digi_phot_ts;		// true hit times of photons in a digit TODO empty
	std::vector<Int_t> digi_phot_parents;	// wcsim track IDs of parents that provided photons for a digit TODO
//	std::vector<WCSimRootCherenkovDigiHit> digits;
	
	// Calculated/Reconstructed Info
	std::vector<Int_t> layers_hit;			// vector of MRD layers hit TODO empty
	std::vector<Double_t> eDepsInLayers;	// fixed length vector of energy deposited in each layer TODO empty
	Double_t KEStart;						// from depth or estimate if fully penetrating - TODO calculate
	Double_t KEEnd;							// 0 for stopping, or estimate if fully penetrating TODO cannot know?
	Double_t mutracklengthinMRD;			// absolute track length from front to end, from track fit
	Double_t penetrationdepth;				// z component of penetration: start of MRD to last hit paddle's z.
	Double_t EnergyLoss;					// based on penetration
	Double_t EnergyLossError;				// based on error in angle and impact on dE/dx
	Int_t particlePID;						// estimated PID
	std::vector<mrdcluster> htrackclusters;	// generated by CA algorithm, used for printing and drawing
	std::vector<mrdcluster> vtrackclusters;	// 
	std::vector<mrdcell> htrackcells;		// cells between horizontally aligned paddles
	std::vector<mrdcell> vtrackcells;		//               vertically 
	
	// Truth information:
	Int_t trueTrackID;						// index in the WCSimRootTrack clones array TODO fill
//	WCSimRootTrack* trueTrack;				// from WCSim GetTracks. Should we keep this?

	// Additional points to include in the fit from bonsia / vertex:
	std::vector<double> extravpoints;
	std::vector<double> extravpointerrors;
	std::vector<double> extrahpoints;
	std::vector<double> extrahpointerrors;
	std::vector<double> extrazpoints;
	std::vector<double> extrazpointerrors;
	
	// Track fit result; fit is a pol1:
	Double_t htrackorigin;
	Double_t htrackoriginerror;
	Double_t htrackgradient;
	Double_t htrackgradienterror;
	Double_t htrackfitchi2;
	TMatrixDSym htrackfitcov{2}; // it's necessary to specify the dimensionality when constructing!!!!
	Double_t vtrackorigin;
	Double_t vtrackoriginerror;
	Double_t vtrackgradient;
	Double_t vtrackgradienterror;
	Double_t vtrackfitchi2;
	TMatrixDSym vtrackfitcov{2};
	
	TVector3 trackfitstart, trackfitstop;
	double trackangle, trackangleerror;
	bool ispenetrating, isstopped, sideexit;
	TVector3 mrdentrypoint; // this is the start point of the fit, not projected to MRD start
	std::pair<double, double> mrdentryxbounds, mrdentryybounds;
	
	bool interceptstank;
	TVector3 projectedtankexitpoint;
	
	public:
	// Track Level Getters
	// ===================
	Int_t GetTrackID(){return MRDtrackID;}
	Int_t GetTankTrackID(){return tanktrackID;}
	// Locate the track in file>run>event>trigger hierarchy
	std::string GetFile(){return wcsimfile;}
	Int_t GetRunID(){return run_id;}
	Int_t GetEventID(){return event_id;}
	Int_t GetMrdSubEventID(){return mrdsubevent_id;}
	Int_t GetTrigger(){return trigger;}
	
	// Top level information about the track
	Int_t GetNumDigits(){return digi_ids.size();}
	Int_t GetNumLayersHit(){return layers_hit.size();}
	Int_t GetNumPMTsHit(){return pmts_hit.size();}
	std::vector<Int_t> GetDigitIds(){return digi_ids;}
	std::vector<Double_t> GetDigitQs(){return digi_qs;}
	std::vector<Double_t> GetDigitTs(){return digi_ts;}
	std::vector<Int_t> GetDigiNumPhots(){return digi_numphots;}
	std::vector<Double_t> GetDigiPhotTs(){return digi_phot_ts;}
	std::vector<Int_t> GetDigiPhotParents(){return digi_phot_parents;}
	std::vector<Int_t> GetLayersHit(){return layers_hit;}
	std::vector<Int_t> GetPMTsHit(){return pmts_hit;}
	
	// Reconstructed Variables
	std::vector<Double_t> GetEdeps(){return eDepsInLayers;}
	Double_t GetKEStart(){return KEStart;}
	Double_t GetKEEnd(){return KEEnd;}
	Double_t GetTotalEdep(){return KEStart-KEEnd;}
	Int_t GetParticlePID(){return particlePID;}
	//TODO: getters for fitparameters
	
	// Information required for matching to tank tracks
	double GetTrackAngle(){return trackangle;}
	double GetTrackAngleError(){return trackangleerror;}
	void GetAngleAndOffset(int tracktype, double &xgradient, double &ygradient, double &xoffset, double &yoffset);
	std::pair<double,double> CalculateCovariantError(double errorx, int indexgiven, TMatrixDSym covariancematrix, bool flag);
	double CalculateCovariantError(double errorx, int indexgiven, TMatrixDSym covariancematrix);
	TVector3 GetMrdEntryPoint(){return mrdentrypoint;}
	std::pair<double, double> GetMrdEntryBoundsX(){return mrdentryxbounds;}
	std::pair<double, double> GetMrdEntryBoundsY(){return mrdentryybounds;}
	bool GetInterceptsTank(){return interceptstank;}
	TVector3 GetTankExitPoint(){return projectedtankexitpoint;}
	double GetStartTime(){
		auto minelementit = std::min_element(digi_ts.begin(), digi_ts.end());
		if(minelementit!=digi_ts.end()) return *minelementit;
		return -1.;
	}
	TVector3 GetStartVertex(){return trackfitstart;}
	TVector3 GetStopVertex(){return trackfitstop;}
	double GetTrackLength(){return mutracklengthinMRD;}
	double GetEnergyLoss(){return EnergyLoss;}
	double GetEnergyLossError(){return EnergyLossError;}
	bool GetIsPenetrating(){return ispenetrating;}
	bool GetIsStopped(){return isstopped;}
	bool GetIsSideExit(){return sideexit;}
	void GetProjectionLimits(double zplane, double &xmax, double &xmin, double &ymax, double &ymin);
	TVector3 GetProjectedPoint(double zplane);
	
	Double_t GetPenetrationDepth(){return penetrationdepth;}
	//WCSimRootTrack* GetTrueTrack(){return trueTrack;}
	Double_t GetHtrackOrigin(){return htrackorigin;}
	Double_t GetHtrackOriginError(){return htrackoriginerror;}
	Double_t GetHtrackGradient(){return htrackgradient;}
	Double_t GetHtrackGradientError(){return htrackgradienterror;}
	Double_t GetHtrackFitChi2(){return htrackfitchi2;}
	std::array<double,2> GetHtrackFitCov(){return std::array<double,2>{htrackfitcov(0,0),htrackfitcov(0,1)};}
	Double_t GetVtrackOrigin(){return vtrackorigin;}
	Double_t GetVtrackOriginError(){return vtrackoriginerror;}
	Double_t GetVtrackGradient(){return vtrackgradient;}
	Double_t GetVtrackGradientError(){return vtrackgradienterror;}
	Double_t GetVtrackFitChi2(){return vtrackfitchi2;}
	std::array<double,2> GetVtrackFitCov(){return std::array<double,2>{vtrackfitcov(0,0),vtrackfitcov(0,1)};}
	
	
	// debugging functions
	void TestCovarianceErrorCalc();
	
	// provided in MRDTrack_Draw_Print.cxx: draw cell arrows from reconstructio
	void DrawReco(TCanvas* imgcanvas, std::vector<TArrow*> &trackarrows, EColor thistrackscolour, std::vector<TBox*> paddlepointers);
	// draw fit line - copy of code to draw truth lines
	void DrawFit(TCanvas* imgcanvas, std::vector<TArrow*> &trackfitarrows, EColor thistrackscolour);
	// print CA info and track info
	void Print();
	void Print2();
	
	// Truth Level Info
	Int_t GetTrueTrackID(){return trueTrackID;}
//	WCSimRootTrack* GetTrueTrack(){return trueTrack;}
	
//	// Digit Level Getters - all the obtainable information about a digit. Or just return the digit?
//	// ===============================
//	Int_t GetPMTNumber(Int_t digitnum){return PMTnum.at(digitnum);}
//	Double_t GetTime(Int_t digitnum){return DigitTs.at(digitnum);}
//	Double_t GetCharge(Int_t digitnum){return DigitQs.at(digitnum);}
//	Double_t GetEdeposited(Int_t digitnum){ return DigitQs.at(digitnum)*3;}	//TODO derive from above. units?
//	Int_t GetNumTrueHits(Int_t digitnum){return NumTrueHits.at(digitnum);}	//size of PhotonIds()
//	std::vector<Int_t> GetPhotonIds(Int_t digitnum){return PhotonIds.at(digitnum);}
//	std::vector<Int_t> GetPhotonParents(Int_t digitnum){return PhotonParents.at(digitnum);}
//	std::vector<Double_t> GetPhotonTrueTimes(Int_t digitnum){return PhotonTrueTimes.at(digitnum);}
//	WCSimRootCherenkovDigiHit* GetDigit(Int_t i){
//		try{return &(digits.at(i));}
//		catch(const std::out_of_range& oor){return 0;}
//	}
	
//	// ---------------------------
//	// digit information not in WCSimRootCherenkovDigiHit
//	// Geometric information about a given digit
//	std::vector<Int_t> MRDlayers;
//	std::vector<Int_t> MRDpaddles;
//	std::vector<std::pair<Double_t, Double_t> > xranges;	// from width of panel(s) hit
//	std::vector<std::pair<Double_t, Double_t> > yranges;	// 
//	std::vector<std::pair<Double_t, Double_t> > zranges;	// from depth of panel
//	std::vector<std::pair<Double_t, Double_t> > tranges; 	// from uncertainty in PMT timing resoluton
//	// ---------------------------
//	Int_t GetLayerNum(Int_t digitnum){return MRDlayers.at(digitnum);}
//	Int_t GetPaddleNum(Int_t digitnum){return MRDpaddles.at(digitnum);}	// number of paddle within this panel
//	std::pair<Double_t, Double_t> GetXrange(Int_t digitnum){return xranges.at(digitnum);}
//	std::pair<Double_t, Double_t> GetYrange(Int_t digitnum){return yranges.at(digitnum);}
//	std::pair<Double_t, Double_t> GetZrange(Int_t digitnum){return zranges.at(digitnum);}
//	std::pair<Double_t, Double_t> GetTrange(Int_t digitnum){return tranges.at(digitnum);}
//	// ---------------------------
	
	// "Setters"
	// =========
//	void AppendDigit(WCSimRootCherenkovDigiHit digitin){digits.push_back(digitin);}
//	void AppendDigit(thisdigitstime, thisdigitsq, thisdigitstubeid, photontimesinatrack, particleidsinatrack);
	void SetTankTrack(Int_t trackidin){tanktrackID = trackidin;}
	void AddTrackPoint(TVector3 pointposition, TVector3 pointerror); // add a point from bonsai, or other external position constraint
	
	// Functions to do reconstruction
	// ==============================
	// Main track reconstruction code
	void DoReconstruction();
	bool CheckTankIntercept(double htrackgradientin, double vtrackgradientin, double htrackoriginin, 
						double vtrackoriginin, TVector3* solution1, TVector3* solution2);
	bool CheckTankIntercept(TVector3* entrypoint, TVector3* exitpoint, int tracktype);
	double GetClosestApproach(TVector3 pointin, int tracktype);
	TVector3 GetClosestPoint(TVector3 origin, int tracktype);
	void DoTGraphErrorsFit();
	void CheckIfStopping();
	void CalculateEnergyLoss();
	
	private:
	// void CalculateParticlePID();  // based on rate of loss? num tracks..? penetration? tank? 
	
	// Static Members
	// ==============
	static Bool_t fillstaticmembers;
	static TF1 MRDenergyvspenetration;
	
	// Default Constructor
	// ====================
	public:
	// Default constructor that initialises all private members required for ROOT classes
	cMRDTrack() : MRDtrackID(-1), wcsimfile(""), run_id(-1), event_id(-1), trigger(-1), mrdsubevent_id(-1), digi_ids(), pmts_hit(), digi_qs(), digi_ts(), digi_numphots(), digi_phot_ts(), digi_phot_parents(), tanktrackID(-1), layers_hit(), eDepsInLayers(), KEStart(-1.), KEEnd(-1.), particlePID(-1), trueTrackID(-1), htrackcells(), vtrackcells(), htrackorigin(-1), htrackoriginerror(-1), htrackgradient(-1), htrackgradienterror(-1), htrackfitchi2(-1), vtrackorigin(-1), vtrackoriginerror(-1), vtrackgradient(-1), vtrackgradienterror(-1), vtrackfitchi2(-1), trackfitstart(TVector3(0,0,0)), trackfitstop(TVector3(0,0,0)), ispenetrating(false), isstopped(false), sideexit(false), penetrationdepth(-1), EnergyLoss(-1), projectedtankexitpoint(TVector3(0,0,0)), interceptstank(false), trackangle(-1.), EnergyLossError(-1), trackangleerror(-1), mrdentryxbounds(), mrdentryybounds(), extravpoints(), extravpointerrors(), extrahpoints(), extrahpointerrors(), extrazpoints(), extrazpointerrors() {};
	
	// destructor
	~cMRDTrack(){cout<<"cMRDTrack destructor (no actions here)"<<endl;}
	
	// Actual Constructor
	// ==================
	cMRDTrack(Int_t mrdtrackidin, std::string wcsimefilein, Int_t runidin, Int_t eventidin, Int_t subeventidin,
	Int_t triggerin, std::vector<Int_t> digitidsin, std::vector<Int_t> digittubesin, std::vector<Double_t>
	digitqsin, std::vector<Double_t> digittimesin, std::vector<Int_t> digitnumphotsin, std::vector<Double_t> 
	digitstruetimesin, std::vector<Int_t> digitsparentsin, std::vector<mrdcell> htrackcellsin, 
	std::vector<mrdcell> vtrackcellsin, std::vector<mrdcluster> htrackclustersin, std::vector<mrdcluster> vtrackclustersin) :
	/* information retrieved when creating the track: initialize with input */
	MRDtrackID(mrdtrackidin), wcsimfile(wcsimefilein), run_id(runidin), event_id(eventidin),
	mrdsubevent_id(subeventidin), trigger(triggerin), digi_ids(digitidsin), pmts_hit(digittubesin),
	digi_qs(digitqsin), digi_ts(digittimesin), digi_numphots(digitnumphotsin), digi_phot_ts(digitstruetimesin),
	digi_phot_parents(digitsparentsin), htrackcells(htrackcellsin), vtrackcells(vtrackcellsin),
	htrackclusters(htrackclustersin), vtrackclusters(vtrackclustersin),
	/* information calculated: initialize to default */
	tanktrackID(-1), layers_hit(), KEStart(-1.), KEEnd(-1.), particlePID(-1),
	trueTrackID(-1), htrackorigin(-1), htrackoriginerror(-1), htrackgradient(-1),
	htrackgradienterror(-1), htrackfitchi2(-1), vtrackorigin(-1), vtrackoriginerror(-1), vtrackgradient(-1),
	vtrackgradienterror(-1), vtrackfitchi2(-1), trackfitstart(TVector3(0,0,0)), 
	trackfitstop(TVector3(0,0,0)), ispenetrating(false), isstopped(false), sideexit(false),
	penetrationdepth(-1), EnergyLoss(-1), projectedtankexitpoint(TVector3(0,0,0)), interceptstank(false),
	trackangle(-1.), EnergyLossError(-1), trackangleerror(-1), mrdentryxbounds(), mrdentryybounds(),
	extravpoints(), extravpointerrors(), extrahpoints(),
	extrahpointerrors(), extrazpoints(), extrazpointerrors() {
	
	if(fillstaticmembers){
		MRDenergyvspenetration.SetParameters(-3.62645, 3.75503, 2.68525, 3.59244, 1.66969);
		fillstaticmembers=false;
	}
	
#ifdef MRDTrack_VERBOSE
		cout<<endl<<"constructing a track with "<<digi_ids.size()<<" digits"<<endl;
#endif
		eDepsInLayers.assign(MRDSpecs::numpanels, 0.);	// can't assign the size in the class def. 
		DoReconstruction();
		
		if((ispenetrating&&isstopped)||(ispenetrating&&sideexit)||(isstopped&&sideexit)){
			cerr<<"ERROR!"<<endl<<"ispenetrating="<<ispenetrating<<", isstopped="<<isstopped<<", sideexit="<<sideexit<<endl;
			assert(false);
		}
		if(trackfitstart.X()<1.&&trackfitstart.Y()<1&&trackfitstart.Z()<1){
			cerr<<"POSSIBLE ERROR!"<<endl<<"Track fit start = ("
				<<trackfitstart.X()<<", "<<trackfitstart.Y()<<", "<<trackfitstart.Z()<<")"<<endl;
			assert(false);
		}
		if(trackfitstop.X()<1.&&trackfitstop.Y()<1&&trackfitstop.Z()<1){
			cerr<<"POSSIBLE ERROR!"<<endl<<"Track fit stop = ("
				<<trackfitstop.X()<<", "<<trackfitstop.Y()<<", "<<trackfitstop.Z()<<")"<<endl;
			assert(false);
		}
	}
	
	// Copy Constructor
	// ================
	cMRDTrack(cMRDTrack const &trackin) :
	MRDtrackID(trackin.MRDtrackID), wcsimfile(trackin.wcsimfile), run_id(trackin.run_id),
	event_id(trackin.event_id), mrdsubevent_id(trackin.mrdsubevent_id), trigger(trackin.trigger),
	digi_ids(trackin.digi_ids), pmts_hit(trackin.pmts_hit), digi_qs(trackin.digi_qs), digi_ts(trackin.digi_ts),
	digi_numphots(trackin.digi_numphots), digi_phot_ts(trackin.digi_phot_ts),
	digi_phot_parents(trackin.digi_phot_parents), tanktrackID(trackin.tanktrackID), 
	layers_hit(trackin.layers_hit), eDepsInLayers(trackin.eDepsInLayers), KEStart(trackin.KEStart),
	KEEnd(trackin.KEEnd), particlePID(trackin.particlePID),
	trueTrackID(trackin.trueTrackID), htrackcells(trackin.htrackcells), vtrackcells(trackin.vtrackcells), 
	htrackclusters(trackin.htrackclusters), vtrackclusters(trackin.vtrackclusters),
	htrackorigin(trackin.htrackorigin), htrackoriginerror(trackin. htrackoriginerror),
	htrackgradient(trackin. htrackgradient), htrackgradienterror(trackin. htrackgradienterror),
	htrackfitchi2(trackin. htrackfitchi2), vtrackorigin(trackin. vtrackorigin),
	vtrackoriginerror(trackin. vtrackoriginerror), vtrackgradient(trackin. vtrackgradient),
	vtrackgradienterror(trackin. vtrackgradienterror), vtrackfitchi2(trackin. vtrackfitchi2),
	trackfitstart(trackin.trackfitstart), trackfitstop(trackin.trackfitstop), 
	ispenetrating(trackin.ispenetrating), isstopped(trackin.isstopped), sideexit(trackin.sideexit),
	penetrationdepth(trackin.penetrationdepth), EnergyLoss(trackin.EnergyLoss), 
	projectedtankexitpoint(trackin.projectedtankexitpoint), interceptstank(trackin.interceptstank),
	trackangle(trackin.trackangle), EnergyLossError(trackin.EnergyLossError), 
	trackangleerror(trackin.trackangleerror), mrdentryxbounds(trackin.mrdentryxbounds), 
	mrdentryybounds(trackin.mrdentryybounds), extravpoints(trackin.extravpoints), 
	extravpointerrors(trackin.extravpointerrors), extrahpoints(trackin.extrahpoints), 
	extrahpointerrors(trackin.extrahpointerrors), extrazpoints(trackin.extrazpoints), 
	extrazpointerrors(trackin.extrazpointerrors)
	/*, digits(trackin.digits), trueTrack(trackin.trueTrack)*/ 
	{
#ifdef MRDTrack_VERBOSE
		cout<<endl<<"copy constructing a track with "<<digi_ids.size()<<" digits"<<endl;
#endif
	}
	
	// End class definition
	// ====================
	ClassDef(cMRDTrack,1);					// INCREMENT VERSION NUM EVERY TIME CLASS MEMBERS CHANGE
};
TF1 cMRDTrack::MRDenergyvspenetration=TF1("af","expo(0)+pol0(2)+([3]/([4]-x))",0,1.6);
//  NO.   NAME      VALUE            ERROR          SIZE      DERIVATIVE 
//   1  p0          -3.62645e+00   2.40923e+01   2.22710e-04   8.81482e-04
//   2  p1           3.75503e+00   1.56841e+01   1.89877e-04   8.82181e-04
//   3  p2           2.68525e+00   7.79532e+00   1.11828e-04   6.30502e-04
//   4  p3           3.59244e+00   1.46368e+01   1.30963e-04   1.08201e-03
//   5  p4           1.66969e+00   6.49103e-01   2.51472e-05  -6.46072e-03
Bool_t cMRDTrack::fillstaticmembers=true;


#include "MRDTrack_DoReconstruction.cxx"	// contains reconstruction function definitions
#include "MRDTrack_Draw_Print.cxx"			// contains definition of print and drawing functions

#ifdef __CINT__
#pragma link C++ class cMRDTrack+;
//#pragma link C++ class ROOT::Math::XYZTVector+;
//#pragma link C++ class std::vector<ROOT::Math::XYZTVector>+;
//#pragma link C++ class cMRDStrike+;
#pragma link C++ class std::vector<cMRDStrike>+;
#endif

#endif

